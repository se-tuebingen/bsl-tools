/*
  This script takes one input parameter:
    - path to the html file which should be screenshotted, relative to the current
      working directory
  If more than one argument are present, it will take the last one!
  It will generate a Screenshot of either
    - the element with the id "screenshot_me"
    - the whole document
  with page width set to 640px;
*/
const puppeteer = require('puppeteer-core');
const fs = require('fs');
const path = require('path');

(async () => {
  const PAGE_WIDTH = 640;
  const PAGE_HEIGHT = 1000;
  const ANIMATION_WAIT_TIME = 2000; // in ms

  // find out platform from file name
  const filename = process.argv[1];
  console.log(`filename is ${filename}`);
  const shortos = 'linux'; //filename.includes('linux') ? 'linux' : (
  //  filename.includes('win') ? 'win' : 'mac'
  //);
  console.log(`inferred OS: ${shortos}`);
  // find browser executable
  const versions = fs.readdirSync(path.join(__dirname, 'chromium'));
  console.log(`found chromium versions: ${versions.join(',')}`);
  const needed = versions.filter(f => f.includes(shortos))[0];
  let osPart;
  if (shortos == 'linux') {
    osPart = 'chrome';
  } else if (shortos == 'win') {
    osPart = 'chrome.exe';
  } else {
    osPart = 'Chromium.app';
  }
  const browserPath = path.join(__dirname, 'chromium', needed, `chrome-${shortos}`, osPart);
  console.log(`trying to launch browser at ${browserPath}`);
  const browser = await puppeteer.launch({ executablePath: browserPath});
  // let browser;
  // if(process.env.CHROMIUM_PATH) {
  //   try {
  //     browser = await puppeteer.launch({ executablePath: process.env.CHROMIUM_PATH});
  //   } catch(e) {
  //     console.error(e);
  //     console.error(`
  //       -----
  //       Error while trying to generate screenshots from HTML graphs generated by
  //       BSL-Tools in order to embed them in pdf output:
  //       ----
  //       Launching Chrome/Chromium from CHROMIUM_PATH=${process.env.CHROMIUM_PATH}
  //       failed, are you sure this is the right path? Try "which chromium" or "which chrome"
  //       on Unix systems, or unset the variable to use the bundled version.
  //     `);
  //     return;
  //   }
  // } else {
  //   try {
  //     console.log(`
  //       -----
  //       Downloading Chromium to generate Screenshots from HTML graphs generated by
  //       BSL-Tools to embed them in pdf output.
  //       Although those downloads are cached, you may want to set the
  //       CHROMIUM_PATH environment variable to your own existing Chrome or Chromium
  //       installation (try "which chromium/chrome" on MaxOS or Linux).
  //     `);
  //     const cont = await chromium.install();
  //     // const revision = await utils.getLatestRevisionNumber();
  //     // console.log(`Fetched revision info: trying to install ${revision}`);
  //     // const browserFetcher = puppeteer.createBrowserFetcher();
  //     // const revisionInfo = await browserFetcher.download(revision);
  //     // console.log('Done downloading');
  //     browser = await puppeteer.launch({
  //       executablePath: chromium.path//revisionInfo.executablePath //.chromium.path
  //     });
  //   } catch(e) {
  //     console.error(e);
  //     console.error(`
  //       -----
  //       Error while trying to generate screenshots from HTML graphs generated by
  //       BSL-Tools in order to embed them in pdf output:
  //       ----
  //       Downloading and launching the Chrome/Chromium version bundled with puppeteer failed.
  //       You could install it yourself and set the CHROMIUM_PATH environment
  //       variable accordingly (try "which chromium" or "which chrome" on Unix systems).
  //     `);
  //   }
  // }

  const page = await browser.newPage();
  await page.setViewport({
    width: PAGE_WIDTH,
    height: PAGE_HEIGHT,
    deviceScaleFactor: 1,
  });
  const wd = process.cwd();
  const file = process.argv[process.argv.length - 1];
  await page.goto(`file://${wd}/${file}`);

  // wait for css transitions
  await new Promise(resolve => setTimeout(resolve, ANIMATION_WAIT_TIME));

  // Get location and extent of element we want to screenshot
  const dimensions = await page.evaluate(() => {
    const ELEMENT_ID = 'screenshot_me';

    let printEl = document.getElementById(ELEMENT_ID);
    if (!printEl) {
      printEl = document.getElementsByTagName('body')[0];
    }
    const pos = printEl.getBoundingClientRect();
    return {
      width: pos.width,
      height: pos.height,
      x: pos.x,
      y: pos.y
    };
  });
  const path_parts = file.split('.');
  path_parts[path_parts.length - 1] = 'png';
  const screenshot_path = path_parts.join('.');
  // generate screenshot
  await page.screenshot({
    path: screenshot_path,
    clip: dimensions
  });

  // console.log('Dimensions:', dimensions);

  await browser.close();
})();
